Задача: найти длину наибольшего префикса слова u, являющегося префиксом слова из L(a)

Построим НКА по обратной польской нотации. Для этого пройдемся по регулярному выражению, если:
1) c in { a, b, c, 1 } 
Добавляем 2 новые вершины в граф, соединяем их ребром и говорим, что одна из них начальное состояние, а другая - конечная в подавтомате на этих 2-ух вершинах. На стек кладем начальное и конечное состояние этого подавтомата
2) c == . 
Снимаем со стека 2 подавтомата. Множества номеров их вершин не пересекаются, значит мы можем провести e-ребро в графе из конечного состояния первого графа в начальное второго, изменить конечное состояние у первого подавтомата и получить, что теперь первый подавтомат задает подавтомат, являющийся конкатенацией двух снятых со стека подавтоматов. Кладем первый подавтомат на стек
3) c == + 
Аналогично, только проводим 2 e-ребра, из начального состояния первого подавтомата в начальное второго и из конечного второго в конечное первого, а конечное состояние первого не меняем
4) c == * 
Снимаем со стека один подавтомат, создаем две новые вершины - новые начальное и конечное состояния. Проводим e-ребра из нового начального в старые начальное и новое конечное, из старого конечного в новое конечное и старое начальное. Кладем обратно на стек

В результате после полного разбора на стеке лежат номера вершин в графе, являющиеся начальным и конечным состоянием нашего НКА.
Более того, из построения получаем, что на каждом шаге добавляеся константное число состояний и ребер, значит V=O(n), E=O(n), где V и E число ребер и вершин, n - длина регулярного выражения

Теперь бежим по нашему слову u. Поддерживаем множество состояний автомата, в которые можно прийти, прочитав префикс длины i слова u. Изначально в нашем множестве только стартовая вершинка. Пусть мы посчитали множество для шага i(current_stages[0]). Покажем, как посчитать множество B для шага i + 1(current_stages[1]). Поочередно перебираем состояния из current_stages[0] и запускаем из них dfs по e-ребрам, который проверяет, существует ли переход из текущего состояния по символу u[i + 1], и в случае положительного ответа добавляет его в current_stages[1]. Теперь заметим, что можно не перебирать соседей вершинки, если мы ее обработали в предыдущем запуске dfs. Таким образом, если сделать массив used, мы получим, что суммарно все dfs работают за O(E) = O(n). Ответ - номер последнего шага, на котором множество не пусто. Итого, мы получили ответ на задачу за O(nk), где n - длина регулярки, k - длина u

P.S. В задаче неправильные сэмплы. Их ответы верны для случая принадлежности префикса u языку, но наше ограничение менее слабое и ответ другой. В обоих семплах ответ 5
